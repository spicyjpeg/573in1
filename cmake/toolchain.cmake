# ps1-bare-metal - (C) 2023 spicyjpeg
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

cmake_minimum_required(VERSION 3.25)

# Create a user-editable variable to allow for a custom toolchain path to be
# specified by passing -DTOOLCHAIN_PATH=... to CMake.
set(
	TOOLCHAIN_PATH "" CACHE PATH
	"Directory containing GCC toolchain executables (if not listed in PATH)"
)

# Prevent CMake from using any host compiler by manually overriding the platform
# and setting it to "generic" (i.e. no defaults).
set(CMAKE_SYSTEM_NAME      Generic)
set(CMAKE_SYSTEM_PROCESSOR mipsel)

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

# Tell CMake not to run the linker when testing the toolchain and to pass our
# custom variables through to autogenerated "compiler test" projects. This will
# prevent the compiler detection process from erroring out.
set(CMAKE_TRY_COMPILE_TARGET_TYPE        STATIC_LIBRARY)
set(CMAKE_TRY_COMPILE_PLATFORM_VARIABLES TOOLCHAIN_PATH TOOLCHAIN_TARGET)

# Always generate compile_commands.json when building. This allows some IDEs and
# tools (such as clangd) to automatically configure include directories and
# other options.
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

## Toolchain path setup

# Attempt to locate the GCC command in the provided path (if any) as well as in
# the system's standard paths for programs such as the ones listed in the PATH
# environment variable. Try to use a mipsel-none-elf toolchain over a
# mipsel-linux-gnu one if available.
find_program(
	_gccPath
		mipsel-none-elf-gcc
		mipsel-unknown-elf-gcc
		mipsel-linux-gnu-gcc
	HINTS
		"${TOOLCHAIN_PATH}"
		"${TOOLCHAIN_PATH}/bin"
		"${TOOLCHAIN_PATH}/../bin"
	NO_CACHE REQUIRED
)
cmake_path(GET _gccPath PARENT_PATH _toolchainPath)

# If a valid path was not provided but GCC was found, overwrite the variable to
# avoid searching again the next time the project is configured.
if(NOT IS_DIRECTORY TOOLCHAIN_PATH)
	set(
		TOOLCHAIN_PATH "${_toolchainPath}" CACHE PATH
		"Directory containing GCC toolchain executables (if not listed in PATH)"
		FORCE
	)
endif()

# Set the paths to all tools required by CMake. The appropriate extension for
# executables (.exe on Windows, none on Unix) is extracted from the path to GCC
# using a regular expression, as CMake does not otherwise expose it when
# cross-compiling.
string(REGEX MATCH "^(.+-)gcc(.*)$" _dummy "${_gccPath}")

set(CMAKE_ASM_COMPILER "${CMAKE_MATCH_1}gcc${CMAKE_MATCH_2}")
set(CMAKE_C_COMPILER   "${CMAKE_MATCH_1}gcc${CMAKE_MATCH_2}")
set(CMAKE_CXX_COMPILER "${CMAKE_MATCH_1}g++${CMAKE_MATCH_2}")
set(CMAKE_AR           "${CMAKE_MATCH_1}ar${CMAKE_MATCH_2}")
set(CMAKE_LINKER       "${CMAKE_MATCH_1}ld${CMAKE_MATCH_2}")
set(CMAKE_RANLIB       "${CMAKE_MATCH_1}ranlib${CMAKE_MATCH_2}")
set(CMAKE_OBJCOPY      "${CMAKE_MATCH_1}objcopy${CMAKE_MATCH_2}")
set(CMAKE_OBJDUMP      "${CMAKE_MATCH_1}objdump${CMAKE_MATCH_2}")
set(CMAKE_NM           "${CMAKE_MATCH_1}nm${CMAKE_MATCH_2}")
set(CMAKE_SIZE         "${CMAKE_MATCH_1}size${CMAKE_MATCH_2}")
set(CMAKE_STRIP        "${CMAKE_MATCH_1}strip${CMAKE_MATCH_2}")
set(CMAKE_READELF      "${CMAKE_MATCH_1}readelf${CMAKE_MATCH_2}")

# Continue initialization by running setup.cmake after project() is invoked.
set(CMAKE_PROJECT_INCLUDE "${CMAKE_CURRENT_LIST_DIR}/setup.cmake")
